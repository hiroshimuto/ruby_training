# 配列
## 配列とは複数のデータをまとめて格納できるオブジェクトの事
## 配列のデータは順番に並んでいて、添え字(インデックス)を指定する事で取り出す事ができる

a = ['apple','orange','melon']
## 配列aの中身を全て取り出す
puts a
## 配列aの1番目の要素を取り出す
puts a[0]

## 配列の中に配列を含めることも可能
a = [['10','20','30'],['40','50','60'],['70','80','90'],]
## 配列aの1番目の要素は['10','20','30']になる
puts a[0]
## もし1番目の要素の10を取り出したい場合は、配列1番目の要素の中の1番目の要素となるため
puts a[0][0]
#となる。

## 存在しない要素を指定しても、エラーにはならずnilが返ってくる。
puts a[100] #⇛ nil

## sizeメソッドは配列の長さ(個数)を取得できる
a = [1,2,3]
puts a.length

# 要素の変更、追加、削除
## 配列[添え字] = 新しい値で値の変更が可能
b = [1,2,3]
# b[0] = 20 とすると、[20,2,3]となる
b[0] = 20
puts b #⇛[20,2,3]

## <<を使うと配列の最後に要素を追加できる
b = []
b << 1
b << 2
b << 3
puts b #⇛ [1,2,3]

## delete_atメソッドを使うと要素の削除が可能
c = [4,5,6]
c.delete_at(1) #⇛5を削除
puts c #⇛[4,6]

# 配列を使った多重代入
a,b = 1,2
puts a #⇛1
puts b #⇛2

## 右辺に配列をおいた場合も同じように多重代入する事が可能
a,b = [1,2]
puts a #⇛1
puts b #⇛2

## 右辺の数が少ない場合はnilが入る
c,d = [3]
puts c #⇛3
puts d #⇛nil

## 右辺の数が多い場合ははみ出した値が切り捨てられる
e,f = [4,5,6]
puts e #⇛4
puts f #⇛5

## 変数に*をつけると、残り全てを配列として受け取れる
a,*b = [1,2,3]
puts a #⇛1
puts b #⇛[2,3]

## 残りの要素が1つでも配列になる
a,*b = [1,2]
puts a #⇛1
puts b #⇛[2]

# ブロック
## ブロックとはメソッドの引数として渡す事ができる処理のかたまり・・・
### ブロックの使い方〜Rubyの繰り返し処理〜
### よくfor文が紹介されるが、実際はfor文よりも配列自身に対して繰り返し処理を命令するeachメソッドが使われる
numbers = [1,2,3,4]
sum = 0
numbers.each do |n|
 sum += n
end
puts sum #⇛n

### 上記では以下の処理が行われている
### ①numbersの配列が設定
### ②sumに0を代入
### ③numbersから要素を一つずつ抽出しnに代入 numbers.each do |n|
### ④sumに取り出した値nを加算 sum += n
### ①〜④を繰り返す do ~ end

## ブロックとはメソッドの引数として渡す事ができる処理のかたまり・・・と先ほど記載しました
## 今回ブロックの範囲は
# do |n|
#  sum += n
# end
#の部分になる。

### |n|のnはブロック引数と呼ばれる。

## 配列の要素を削除する条件を設定する
a = [1,2,3,1,2,3]
## 奇数だけ削除したい場合はdelete_ifメソッドを使用する
a.delete_if do |n|
  n.odd?
end
puts a #⇛[2,2]

### delete_ifメソッドはブロックの戻り値をチェックし、真であればブロックに渡した要素を削除し、偽であれば配列に残したままにする

### do~endのブロック処理の中で、n.odd?(odd?メソッドで奇数かどうか)を判別している
### ブロック内部には、要件によって異なる処理を記述していく

## do~endと{}
### do~endは{}という書き方で省略可能

numbers = [1,2,3,4]
sum = 0

numbers.each do |n|
  sum += n
end

numbers.each {|n| sum += n}

### 改行を含む長い処理をブロックに書く時はdo~end
### 1行でコンパクトに収めたい時は{}を使う


